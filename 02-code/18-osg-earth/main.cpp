#include <osgGA/StateSetManipulator>
#include <osgGA/GUIEventHandler>
#include <osgViewer/Viewer>
#include <osgViewer/ViewerEventHandlers>
#include <osgUtil/LineSegmentIntersector>
#include <osgEarth/MapNode>
#include <osgEarth/TerrainEngineNode>
#include <osgEarth/ElevationQuery>
#include <osgEarth/StringUtils>
#include <osgEarth/Terrain>
#include <osgEarthUtil/EarthManipulator>
#include <osgEarthUtil/Controls>
#include <osgEarthUtil/LatLongFormatter>
#include <iomanip>

using namespace osgEarth;
using namespace osgEarth::Util;
using namespace osgEarth::Util::Controls;

static MapNode*       s_mapNode     = 0L;
static LabelControl*  s_posLabel    = 0L;
static LabelControl*  s_vdaLabel    = 0L;
static LabelControl*  s_mslLabel    = 0L;
static LabelControl*  s_haeLabel    = 0L;
static LabelControl*  s_mapLabel    = 0L;
static LabelControl*  s_resLabel    = 0L;


// An event handler that will print out the elevation at the clicked point
//查询高程的一个事件回调，在场景有事件更新触发时调用，详细参考osg或者osgGA::GUIEventHandler
struct QueryElevationHandler : public osgGA::GUIEventHandler
{
//构造函数
QueryElevationHandler()
: _mouseDown( false ),
_terrain  ( s_mapNode->getTerrain() ),
_query    ( s_mapNode->getMap() )
{
_map = s_mapNode->getMap();

//初始化最大查询LOD级别
_query.setMaxTilesToCache(10);

_path.push_back( s_mapNode->getTerrainEngine() );
}
//更新回调，具体的内容可以参考父类，传进来的参数是屏幕坐标xy，和osgViewer
void update( float x, float y, osgViewer::View* view )
{
bool yes = false;

// look under the mouse:
//采用线去对地球做碰撞检测，根据鼠标点击点去检测，得到交点，就是当前点的xyz
osg::Vec3d world;
osgUtil::LineSegmentIntersector::Intersections hits;
//判断求交结果是否为空
if ( view->computeIntersections(x, y, hits) )
{
//得到世界坐标系下面的坐标，就是osg的xyz坐标
world = hits.begin()->getWorldIntersectPoint();

// convert to map coords:
//将其转换为地球的地理坐标，转换方法都照抄即可
GeoPoint mapPoint;
mapPoint.fromWorld( _terrain->getSRS(), world );

// do an elevation query:
double query_resolution = 0; // 1/10th of a degree
double out_hamsl        = 0.0;
double out_resolution   = 0.0;

//根据输入参数查询当前点位置的高程，需要设置分辨率，就是查询精度
bool ok = _query.getElevation(
mapPoint,
out_hamsl,
query_resolution,
&out_resolution );

//如果查询成功
if ( ok )
{
// convert to geodetic to get the HAE:
mapPoint.z() = out_hamsl;
GeoPoint mapPointGeodetic( s_mapNode->getMapSRS()->getGeodeticSRS(), mapPoint );

//经纬度坐标的格式化工具，也可以自己用字符串去拼接xyz数字
static LatLongFormatter s_f;

//更新显示的xyz值，label是传入的控件
s_posLabel->setText( Stringify()
<< std::fixed << std::setprecision(2)
<< s_f.format(mapPointGeodetic.y())
<< ", "
<< s_f.format(mapPointGeodetic.x()) );

//还可以输出分辨率，椭球体信息等
s_mslLabel->setText( Stringify() << out_hamsl );
s_haeLabel->setText( Stringify() << mapPointGeodetic.z() );
s_resLabel->setText( Stringify() << out_resolution );

yes = true;
}

// finally, get a normal ISECT HAE point.
GeoPoint isectPoint;
isectPoint.fromWorld( _terrain->getSRS()->getGeodeticSRS(), world );
s_mapLabel->setText( Stringify() << isectPoint.alt() );
}

//如果查询不到高程的话
if (!yes)
{
s_posLabel->setText( "-" );
s_mslLabel->setText( "-" );
s_haeLabel->setText( "-" );
s_resLabel->setText( "-" );
}
}

//参数一个是事件的动作，另外一个是对应的操作
bool handle( const osgGA::GUIEventAdapter& ea, osgGA::GUIActionAdapter& aa )
{
//判断如果是移动鼠标事件才进行更新当前的坐标显示
if (ea.getEventType() == osgGA::GUIEventAdapter::MOVE &&
aa.asView()->getFrameStamp()->getFrameNumber() % 10 == 0)
{
osgViewer::View* view = static_cast<osgViewer::View*>(aa.asView());
update( ea.getX(), ea.getY(), view );
}

return false;
}

//Map对象
const Map*       _map;
//地形对象
const Terrain*   _terrain;
bool             _mouseDown;
//查询高程使用的对象
ElevationQuery   _query;
osg::NodePath    _path;
};

//main函数，
int main(int argc, char** argv)
{
//这儿两个参数，第一个是命令参数的个数为，后面是字符串数组输入earth文件的路径osg::ArgumentParser arguments(&argc,argv);

//osg的场景
osgViewer::Viewer viewer(arguments);
//构造MapNode，arguments里面有earth文件的路径，命令行输入
s_mapNode = MapNode::load(arguments);
//如果路径不正确或者earth文件错误，没有构造好MapNode
if ( !s_mapNode )
{
OE_WARN << "Unable to load earth file." << std::endl;
return -1;
}
//建立一个组节点
osg::Group* root = new osg::Group();
//将组节点设置为场景节点
viewer.setSceneData( root );

// install the programmable manipulator.
//设置earth操作器
viewer.setCameraManipulator( new osgEarth::Util::EarthManipulator() );

// The MapNode will render the Map object in the scene graph.
//将MapNode添加到组节点中去
root->addChild( s_mapNode );

//下面是设置一个控件，grid的意思是用格网去布局里面的小控件
// Make the readout:
Grid* grid = new Grid();
//设置几个Label文字控件显示在场景中的第行
grid->setControl(0,0,new LabelControl("Coords (Lat, Long):"));
grid->setControl(0,1,new LabelControl("Vertical Datum:"));
grid->setControl(0,2,new LabelControl("Height (MSL):"));
grid->setControl(0,3,new LabelControl("Height (HAE):"));
grid->setControl(0,4,new LabelControl("Isect  (HAE):"));
grid->setControl(0,5,new LabelControl("Resolution:"));
//设置几个Label文字控件显示在场景中的第行
s_posLabel = grid->setControl(1,0,new LabelControl(""));
s_vdaLabel = grid->setControl(1,1,new LabelControl(""));
s_mslLabel = grid->setControl(1,2,new LabelControl(""));
s_haeLabel = grid->setControl(1,3,new LabelControl(""));
s_mapLabel = grid->setControl(1,4,new LabelControl(""));
s_resLabel = grid->setControl(1,5,new LabelControl(""));

//得到空间参考，椭球面信息，并显示对应上面的label
const SpatialReference* mapSRS = s_mapNode->getMapSRS();
s_vdaLabel->setText( mapSRS->getVerticalDatum() ?
mapSRS->getVerticalDatum()->getName() :
Stringify() << "geodetic (" << mapSRS->getEllipsoid()->getName() << ")" );

//控件绘制容器
ControlCanvas* canvas = new ControlCanvas();
//将要显示的控件加入到root组节点中去
root->addChild(canvas);
canvas->addControl( grid );

//添加刚刚自定义的查询高程的事件回调
// An event handler that will respond to mouse clicks:
viewer.addEventHandler( new QueryElevationHandler() );
//添加状态显示，窗口改变等事件回调
// add some stock OSG handlers:
viewer.addEventHandler(new osgViewer::StatsHandler());
viewer.addEventHandler(new osgViewer::WindowSizeHandler());
viewer.addEventHandler(new osgGA::StateSetManipulator(viewer.getCamera()->getOrCreateStateSet()));

//run
return viewer.run();
}
